## @section Global parameters
## Global Docker image parameters
## Please, note that this will override the image parameters
## @param global.imagePullSecrets Global Docker registry secret names as an array
##
global:
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []

## @section Common parameters
##


## @param commonLabels Labels to add to all deployed objects
##
commonLabels: {}
## @param commonAnnotations Annotations to add to all deployed objects
##
commonAnnotations: {}


debug: false

size: medium # small | medium | large
presets:
  small:
    collectorWorker:
      replicas: 1
    measurementAnalysis: 
      replicas: 1
    pipelineWorker: 
      replicas: 1
  medium:
    collectorWorker:
      replicas: 4
    measurementAnalysis: 
      replicas: 4
    pipelineWorker: 
      replicas: 1
  large:
    collectorWorker:
      replicas: 6
    measurementAnalysis: 
      replicas: 4
    pipelineWorker: 
      replicas: 4

deploymentType: Helm
exposeInternalErrorDetails: true
imagePullSecretName:
tolerations:
nodeSelector:

traceCollectorThresholds:
  recentActivityUpdateThresholdSeconds: 5
  upsertEndpointThresholdSeconds: 5
  upsertSpansThresholdSeconds: 5
  upsertSpanFlowMetadataThresholdSeconds: 5

kafka:
  host: "{{ .Release.Name }}-kafka"
  imageTag: 3.5.1
  resources: {
    requests: {
      memory: 400Mi,
      cpu: 200m
    },
    limits: {
      memory: 3Gi,
      cpu: 1000m
    }
  }
  annotations: {}
  labels: {}
  args: []
  

influxdb:
  resources: {
    requests: {
      memory: 500Mi,
      cpu: 500m
    },
    limits: {
      memory: 2Gi,
      cpu: 2000m
    }
  }
  auth:
    user:
      org: digma
      username: admin
      password: "12345678"
      bucket: errors
    admin:
      org: digma
      username: admin
      password: "12345678"
      token: dc61908e-05bc-411a-9fe2-e3356b8dc7c0
      bucket: errors
      retention: 4w
  service:
    ports:
      http: 8086
  persistence:
    enabled: true
    accessModes:
    - ReadWriteOnce
    size: 50Gi
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
## https://github.com/bitnami/charts/tree/f29e7aa40d82f5ee914ca9f642743e5b1c4ce128/bitnami/postgresql#readme
postgresql:
  enabled: true
  auth:
    database: postgres
    username: postgres
    password: postgres
    enablePostgresUser: false
  architecture: standalone
  containerPorts:
    postgresql: 5432
  primary:
    resources: {
      requests: {
        memory: 1Gi,
        cpu: 200m
      },
      limits: {
        memory: 2Gi,
        cpu: 1000m
      }
    }
    networkPolicy:
      enabled: false
    service:
      ports:
        postgresql: 5432
    persistence:
      enabled: true
      accessModes:
      - ReadWriteOnce
      size: 20Gi
    extendedConfiguration: |
      shared_buffers = '800MB'
      logging_collector = on
      log_directory ='log'

    extraEnvVars:
      - name: POSTGRESQL_MAX_CONNECTIONS
        value: "400"

    ## Extra labels for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    ##
    podLabels: {}
    ## Annotations for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    ##
    podAnnotations: {}

    ## Node labels for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
    ##
    nodeSelector: {}
    ## Tolerations for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []

## Redis&reg; chart configuration
## ref: https://github.com/bitnami/charts/blob/main/bitnami/redis/values.yaml
## @param redis.enabled Switch to enable or disable the Redis&reg; helm
## @param redis.auth.enabled Enable password authentication
## @param redis.auth.password Redis&reg; password
## @param redis.auth.existingSecret The name of an existing secret with Redis&reg; credentials
## @param redis.architecture Redis&reg; architecture. Allowed values: `standalone` or `replication`
##
redis:
  enabled: true
  auth:
    enabled: false
  architecture: standalone
  master:
    extraFlags:
        ## The maxmemory configuration directive is used in order to configure Redis(R) to use a specified
        ## amount of memory for the data set. Setting maxmemory to zero results into no memory limits
        ## see https://redis.io/topics/lru-cache for more details
        ##
        - "--maxmemory 2g"
        ## The exact behavior Redis(R) follows when the maxmemory limit is reached is configured using the
        ## maxmemory-policy configuration directive
        ## allkeys-lru: evict keys by trying to remove the less recently used (LRU) keys first, in order
        ## to make space for the new data added
        ##
        - "--maxmemory-policy allkeys-lru"
    resources:
      requests:
        memory: "100Mi"
        cpu: "50m"
      limits:
        memory: "2Gi"
        cpu: "400m"
    persistence:
      enabled: true
      accessModes:
      - ReadWriteOnce
      size: 10Gi
    ## Extra labels for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    ##
    podLabels: {}
    ## Annotations for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    ##
    podAnnotations: {}

    ## Node labels for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
    ##
    nodeSelector: {}
    ## Tolerations for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []


pgadmin:
  host: "{{ .Release.Name }}-pgadmin"
  email: admin@admin.com
  password: admin

jaeger:
  image:
    registry: docker.io
    repository: jaegertracing/all-in-one
    tag: 1.61.0
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: Always
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: 1
  resources: {
    requests: {
      memory: 300Mi,
      cpu: 100m
    },
    limits: {
      memory: 800Mi,
      cpu: 800m
    }
  }
  service:
    ## Kubernetes service type (`ClusterIP`, `NodePort` or `LoadBalancer`)
    ##
    type: ClusterIP

    ports: 
      grpc_internal: 4317
      http_ui: 16686

    ## Annotations for service
    ##
    annotations: {}
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []

  ## Configure the ingress resource that allows you to access the
  ## Service. Set up the URL
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ##
  ingress:
    ## Enable ingress controller resource
    ##
    enabled: true
    ## Override API Version (automatically detected if not set)
    ##
    apiVersion: ""
    ## Default host for the ingress resource
    ##
    hostname: 123.jaeger.digma.systems
    ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
    ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
    ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
    ##
    ingressClassName: "alb"
    ## Ingress Path type
    ##
    pathType: ImplementationSpecific
    ## The Path to service. You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /*
    ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
    ## For a full list of possible ingress annotations, please see
    ## ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md
    ## Use this parameter to set the required annotations for cert-manager, see
    ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
    ##
    ## e.g:
    ## annotations:
    ##   kubernetes.io/ingress.class: nginx
    ##   cert-manager.io/cluster-issuer: cluster-issuer-name
    ##
    annotations:
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/target-type: ip #facilitating efficient load balancing for services exposed via ClusterIP
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-west-1:585085114703:certificate/b3e183fd-0615-4b61-b37e-2605b9eb4283
      alb.ingress.kubernetes.io/group.name: "digma-public"


    ## Additional arbitrary path/backend objects
    ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## Additional rules to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    ## e.g:
    ## extraRules:
    ## - host: example.local
    ##     http:
    ##       path: /
    ##       backend:
    ##         service:
    ##           name: example-svc
    ##           port:
    ##             name: http
    ##
    extraRules: []
  ## Unique key you’ll need to provide any IDE that connects to this Digma instance, you can choose any token you'd like
  args: []


kibana:
  host: "{{ .Release.Name }}-kibana"

redisCommander:
  host: "{{ .Release.Name }}-redis-commander"

elasticApmServer:
  host: "{{ .Release.Name }}-apm"


collectorWorker:
  image:
    registry: docker.io
    repository: digmatic/digma-collector-worker
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: "{{ index .Values.presets .Values.size \"collectorWorker\" \"replicas\" }}"
  resources: {
    requests: {
      memory: 300Mi,
      cpu: 300m
    },
    limits: {
      memory: 600Mi,
      cpu: 600m
    }
  }
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Affinity for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  env:
  - name: "Sampling__Enable"
    value: "true"
  - name: "ExtendedObservability__Enable"
    value: "true"
  - name: "TraceTempStorage__TraceForJaegerExpirationInMinutes"
    value: "10"
  - name: BlockedTrace__TraceSpansLimit
    value: "3000"
  app:
    ignoreEndpoints:
      - Route: "/health"
        RouteRegex: ""
        Method: "GET"
        Service: "*"
      - Route: "/healthcheck"
        RouteRegex: ""
        Method: "GET"
        Service: "*"
      - Route: "/metrics"
        RouteRegex: ""
        Method: "GET"
        Service: "*"

otelCollector:
  image:
    registry: docker.io
    repository: otel/opentelemetry-collector-contrib
    tag: 0.103.0
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  samplingPercentage: 100
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    limits:
      cpu: 200m
      memory: 300Mi
  service:
    ## @param service type (`ClusterIP`, `NodePort` or `LoadBalancer`)
    ##
    type: ClusterIP
    ## @param Annotations for service
    ##
    annotations: {}
    ports:
      health: 13133
      ## should set http or grpc not both of them
      grpc: 4317
      http: 4318
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ##  Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ##  Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ##  Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## Configure the ingress resource that allows you to access the
  ## Service. Set up the URL
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ##
  grpc:
    ingress:
      ##  Enable ingress controller resource
      ##
      enabled: true
      ##  Override API Version (automatically detected if not set)
      ##
      apiVersion: ""
      ##  Default host for the ingress resource
      ##
      hostname: 123.collector-grpc.digma.systems
      ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
      ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
      ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
      ##
      ingressClassName: "alb"
      ## Ingress Path type
      ##
      pathType: ImplementationSpecific
      
      ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
      ## For a full list of possible ingress annotations, please see
      ## ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md
      ## Use this parameter to set the required annotations for cert-manager, see
      ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
      ##
      ## e.g:
      ## annotations:
      ##   kubernetes.io/ingress.class: nginx
      ##   cert-manager.io/cluster-issuer: cluster-issuer-name
      ##
      annotations:
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: ip #facilitating efficient load balancing for services exposed via ClusterIP
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
        alb.ingress.kubernetes.io/backend-protocol-version: GRPC
        alb.ingress.kubernetes.io/backend-protocol: HTTP
        #alb.ingress.kubernetes.io/load-balancer-attributes: routing.http2.enabled=true
        alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-west-1:585085114703:certificate/b3e183fd-0615-4b61-b37e-2605b9eb4283
        # alb.ingress.kubernetes.io/healthcheck-path: "/health"
        # alb.ingress.kubernetes.io/healthcheck-protocol: "HTTP"
        # alb.ingress.kubernetes.io/healthcheck-port: "health"
        # alb.ingress.kubernetes.io/healthcheck-interval-seconds: "30"
        # alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
        # alb.ingress.kubernetes.io/healthcheck-healthy-threshold-count: "3"
        # alb.ingress.kubernetes.io/healthcheck-unhealthy-threshold-count: "3"
        alb.ingress.kubernetes.io/group.name: "digma-public"
      ## Additional arbitrary path/backend objects
      ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
      ## extraPaths:
      ## - path: /*
      ##   backend:
      ##     serviceName: ssl-redirect
      ##     servicePort: use-annotation
      ##
      extraPaths: []
      ## Additional rules to be covered with this ingress record
      ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      ## e.g:
      ## extraRules:
      ## - host: example.local
      ##     http:
      ##       path: /
      ##       backend:
      ##         service:
      ##           name: example-svc
      ##           port:
      ##             name: http
      ##
      extraRules: []
  http:
    ingress:
      ##  Enable ingress controller resource
      ##
      enabled: true
      ##  Override API Version (automatically detected if not set)
      ##
      apiVersion: ""
      ##  Default host for the ingress resource
      ##
      hostname: 123.collector-http.digma.systems
      ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
      ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
      ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
      ##
      ingressClassName: "alb"
      ## Ingress Path type
      ##
      pathType: ImplementationSpecific
      
      ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
      ## For a full list of possible ingress annotations, please see
      ## ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md
      ## Use this parameter to set the required annotations for cert-manager, see
      ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
      ##
      ## e.g:
      ## annotations:
      ##   kubernetes.io/ingress.class: nginx
      ##   cert-manager.io/cluster-issuer: cluster-issuer-name
      ##
      annotations:
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: ip #facilitating efficient load balancing for services exposed via ClusterIP
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
        alb.ingress.kubernetes.io/backend-protocol: HTTP
        #alb.ingress.kubernetes.io/load-balancer-attributes: routing.http2.enabled=true
        alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-west-1:585085114703:certificate/b3e183fd-0615-4b61-b37e-2605b9eb4283
        alb.ingress.kubernetes.io/healthcheck-path: "/health"
        alb.ingress.kubernetes.io/healthcheck-protocol: "HTTP"
        alb.ingress.kubernetes.io/healthcheck-port: "health"
        alb.ingress.kubernetes.io/healthcheck-interval-seconds: "30"
        alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
        alb.ingress.kubernetes.io/healthcheck-healthy-threshold-count: "3"
        alb.ingress.kubernetes.io/healthcheck-unhealthy-threshold-count: "3"

        alb.ingress.kubernetes.io/group.name: "digma-public"
      ## Additional arbitrary path/backend objects
      ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
      ## extraPaths:
      ## - path: /*
      ##   backend:
      ##     serviceName: ssl-redirect
      ##     servicePort: use-annotation
      ##
      extraPaths: []
      ## Additional rules to be covered with this ingress record
      ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      ## e.g:
      ## extraRules:
      ## - host: example.local
      ##     http:
      ##       path: /
      ##       backend:
      ##         service:
      ##           name: example-svc
      ##           port:
      ##             name: http
      ##
      extraRules: []
collectorApi:
  image:
    registry: docker.io
    repository: digmatic/digma-collector
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: 1
  resources: {
    requests: {
      memory: 100Mi,
      cpu: 200m
    },
    limits: {
      memory: 600Mi,
      cpu: 800m
    }
  }
  service:
    ## service type (`ClusterIP`, `NodePort` or `LoadBalancer`)
    ##
    type: ClusterIP
    ##  Annotations for service
    ##
    annotations: {}

    ports:
      internal: 5048
      grpc: 5050
      http: 5049

  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
   
  ## Configure the ingress resource that allows you to access the
  ## Service. Set up the URL
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ##
  ingress:
    ## Enable ingress controller resource
    ##
    enabled: false
    ## Override API Version (automatically detected if not set)
    ##
    apiVersion: ""
    ## Default host for the ingress resource
    ##
    hostname: ""
    ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
    ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
    ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
    ##
    ingressClassName: "alb"
    ## Ingress Path type
    ##
    pathType: ImplementationSpecific
    ## The Path to service. You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /*
    ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
    ## For a full list of possible ingress annotations, please see
    ## ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md
    ## Use this parameter to set the required annotations for cert-manager, see
    ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
    ##
    ## e.g:
    ## annotations:
    ##   kubernetes.io/ingress.class: nginx
    ##   cert-manager.io/cluster-issuer: cluster-issuer-name
    ##
    annotations: {}
    ## Additional arbitrary path/backend objects
    ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## Additional rules to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    ## e.g:
    ## extraRules:
    ## - host: example.local
    ##     http:
    ##       path: /
    ##       backend:
    ##         service:
    ##           name: example-svc
    ##           port:
    ##             name: http
    ##
    extraRules: []
analyticsApi:
  image:
    registry: docker.io
    repository: digmatic/digma-analytics
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  secured: false # must be false if ingress.enabled=true
  replicas: 1
  resources: {
    requests: {
      memory: 300Mi,
      cpu: 100m
    },
    limits: {
      memory: 800Mi,
      cpu: 800m
    }
  }
  service:
    ## Kubernetes service type (`ClusterIP`, `NodePort` or `LoadBalancer`)
    ##
    type: ClusterIP
    ports:
      http: 5051
    ## Annotations for service
    ##
    annotations: {}
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []

  ## Configure the ingress resource that allows you to access the
  ## Service. Set up the URL
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ##
  ingress:
    ## Enable ingress controller resource
    ##
    enabled: true
    ## Override API Version (automatically detected if not set)
    ##
    apiVersion: ""
    ## Default host for the ingress resource
    ##
    hostname: 123.api.digma.systems
    ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
    ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
    ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
    ##
    ingressClassName: "alb"
    ## Ingress Path type
    ##
    pathType: ImplementationSpecific
    ## The Path to service. You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /*
    ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
    ## For a full list of possible ingress annotations, please see
    ## ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md
    ## Use this parameter to set the required annotations for cert-manager, see
    ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
    ##
    ## e.g:
    ## annotations:
    ##   kubernetes.io/ingress.class: nginx
    ##   cert-manager.io/cluster-issuer: cluster-issuer-name
    ##
    annotations:
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/target-type: ip #facilitating efficient load balancing for services exposed via ClusterIP
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-west-1:585085114703:certificate/b3e183fd-0615-4b61-b37e-2605b9eb4283
      alb.ingress.kubernetes.io/healthcheck-path: "/healthz"
      alb.ingress.kubernetes.io/healthcheck-protocol: "HTTP"
      alb.ingress.kubernetes.io/healthcheck-port: "traffic-port"
      alb.ingress.kubernetes.io/healthcheck-interval-seconds: "30"
      alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
      alb.ingress.kubernetes.io/healthcheck-healthy-threshold-count: "3"
      alb.ingress.kubernetes.io/healthcheck-unhealthy-threshold-count: "3"
      alb.ingress.kubernetes.io/group.name: "digma-public"


    ## Additional arbitrary path/backend objects
    ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## Additional rules to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    ## e.g:
    ## extraRules:
    ## - host: example.local
    ##     http:
    ##       path: /
    ##       backend:
    ##         service:
    ##           name: example-svc
    ##           port:
    ##             name: http
    ##
    extraRules: []
  ## Unique key you’ll need to provide any IDE that connects to this Digma instance, you can choose any token you'd like
  accessToken:
measurementAnalysis:
  image:
    registry: docker.io
    repository: digmatic/digma-measurement-analysis
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: "{{ index .Values.presets .Values.size \"measurementAnalysis\" \"replicas\" }}"
  resources: {
    requests: {
      memory: 100Mi,
      cpu: 200m
    },
    limits: {
      memory: 800Mi,
      cpu: 800m
    }
  }
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Affinity for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
scheduler:
  image:
    registry: docker.io
    repository: digmatic/digma-scheduler
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: 1

  resources: {
    requests: {
      memory: 300Mi,
      cpu: 200m
    },
    limits: {
      memory: 600Mi,
      cpu: 500m
    }
  }
  service:
    ## service type (`ClusterIP`, `NodePort` or `LoadBalancer`)
    ##
    type: ClusterIP
    ##  Annotations for service
    ##
    annotations: {}

    ports:
      internal: 3053

  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Affinity for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
pipelineWorker:
  image:
    registry: docker.io
    repository: digmatic/digma-pipeline-worker
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: "{{ index .Values.presets .Values.size \"pipelineWorker\" \"replicas\" }}"
  resources: {
    requests: {
      memory: 100Mi,
      cpu: 50m
    },
    limits: {
      memory: 400Mi,
      cpu: 500m
    }
  }
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Affinity for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ##
  affinity: {}
  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
ui:
  image:
    registry: docker.io
    repository: digmaai/digma-ui
    tag: 2.1.4
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: 1
  resources: 
  requests: 
    memory: 100Mi
    cpu: 100m
  limits: 
    memory: 200Mi
    cpu: 200m
    
  service:
    ## Kubernetes service type (`ClusterIP`, `NodePort` or `LoadBalancer`)
    ##
    type: ClusterIP
    ports:
      http: 80
    ## Annotations for service
    ##
    annotations: {}
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []

  ## Configure the ingress resource that allows you to access the
  ## Service. Set up the URL
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ##
  ingress:
    ## Enable ingress controller resource
    ##
    enabled: true
    ## Override API Version (automatically detected if not set)
    ##
    apiVersion: ""
    ## Default host for the ingress resource
    ##
    hostname: 123.ui.digma.systems
    ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
    ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
    ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
    ##
    ingressClassName: "alb"
    ## Ingress Path type
    ##
    pathType: ImplementationSpecific
    ## The Path to service. You may need to set this to '/*' in order to use this with ALB ingress controllers
    ##
    path: /*
    ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
    ## For a full list of possible ingress annotations, please see
    ## ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md
    ## Use this parameter to set the required annotations for cert-manager, see
    ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
    ##
    ## e.g:
    ## annotations:
    ##   kubernetes.io/ingress.class: nginx
    ##   cert-manager.io/cluster-issuer: cluster-issuer-name
    ##
    annotations:
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/target-type: ip #facilitating efficient load balancing for services exposed via ClusterIP
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-west-1:585085114703:certificate/b3e183fd-0615-4b61-b37e-2605b9eb4283
      alb.ingress.kubernetes.io/group.name: "digma-public"


    ## Additional arbitrary path/backend objects
    ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
    ## extraPaths:
    ## - path: /*
    ##   backend:
    ##     serviceName: ssl-redirect
    ##     servicePort: use-annotation
    ##
    extraPaths: []
    ## Additional rules to be covered with this ingress record
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    ## e.g:
    ## extraRules:
    ## - host: example.local
    ##     http:
    ##       path: /
    ##       backend:
    ##         service:
    ##           name: example-svc
    ##           port:
    ##             name: http
    ##
    extraRules: []
# @section Elasticsearch chart configuration
## https://github.com/bitnami/charts/blob/main/bitnami/elasticsearch/values.yaml
##
elasticsearch:
  ## @param elasticsearch.enabled Whether to deploy a elasticsearch server to use as Mastodon's search engine
  ## To use an external server set this to false and configure the externalElasticsearch parameters
  ##
  enabled: true
  ## @param elasticsearch.sysctlImage.enabled Enable kernel settings modifier image for Elasticsearch
  ##
  sysctlImage:
    enabled: true
  ## @param elasticsearch.security.enabled Enable security settings for Elasticsearch
  ## @param elasticsearch.security.existingSecret Name of an existing secret containing the elasticsearch credentials
  ## @param elasticsearch.security.tls.restEncryption Enable TLS encryption for REST API
  ##
  security:
    enabled: false
    existingSecret: ""
    tls:
      restEncryption: false
  ## Elasticsearch master-eligible node parameters
  ## @param elasticsearch.master.replicaCount Desired number of Elasticsearch master-eligible nodes
  ##
  master:
    masterOnly: false
    replicaCount: 1
    terminationGracePeriodSeconds: 5
    podSecurityContext:
      enabled: true
      fsGroup: 1000
    persistence:
      enabled: true
      size: 80Gi
      accessModes:
      - ReadWriteOnce
    resources: {
      requests: {
        memory: 2Gi,
        cpu: 1
      },
      limits: {
        memory: 4Gi,
        cpu: 2
      }
    }
    extraEnvVars:
    - name: ES_JAVA_OPTS
      value: "-server -Xms1G -Xmx2G"
    ## Extra labels for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    ##
    podLabels: {}
    ## Annotations for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    ##
    podAnnotations: {}

    ## Affinity for pod assignment
    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    ##
    affinity: {}
    ## Node labels for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
    ##
    nodeSelector: {}
    ## Tolerations for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []
    
  ## Elasticsearch coordinating-only node parameters
  ## @param elasticsearch.coordinating.replicaCount Desired number of Elasticsearch coordinating-only nodes
  ##
  coordinating:
    replicaCount: 0
  ## Elasticsearch data node parameters
  ## @param elasticsearch.data.replicaCount Desired number of Elasticsearch data nodes
  ##
  data:
    replicaCount: 0
  ## Elasticsearch ingest node parameters
  ## @param elasticsearch.ingest.replicaCount Desired number of Elasticsearch ingest nodes
  ##
  ingest:
    replicaCount: 0
  ## @param elasticsearch.service.ports.restAPI Elasticsearch REST API port
  ##
  service:
    ports:
      restAPI: 9200

grafana2:
  host: "{{ .Release.Name }}-grafana"
  annotations: {}
  labels: {}
  args: []

grafana:
  admin:
    user: admin
    password: admin
  dashboardsProvider:
    enabled: true
  dashboardsConfigMaps:
  - configMapName: digma-grafana-activities-dashboards
    fileName: activities.json
  - configMapName: digma-grafana-environment-dashboards
    fileName: environment.json
  - configMapName: digma-grafana-kafka-dashboards
    fileName: kafka.json
  datasources:
    secretName: grafana-datasource
  grafana:
    resources: 
      requests: 
        memory: 512Mi
        cpu: 500m
      limits: 
        memory: 768Mi
        cpu: 750m
    ## Extra labels for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    ##
    podLabels: {}
    ##  Annotations for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    ##
    podAnnotations: {}

    ##  Node labels for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
    ##
    nodeSelector: {}
    ##  Tolerations for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []

prometheus:
  fullnameOverride: "digma-prometheus"
  alertmanager:
    enabled: false
  server:
    existingConfigmap: "digma-prometheus-service"
    existingConfigmapKey: "prometheus.yaml"
    service:
      type: ClusterIP
      ports:
        http: 9090
    resources: 
      requests: 
        memory: 512Mi
        cpu: 500m
      limits: 
        memory: 768Mi
        cpu: 750m
    ## Extra labels for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    ##
    podLabels: {}
    ##  Annotations for pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    ##
    podAnnotations: {}

    ##  Node labels for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
    ##
    nodeSelector: {}
    ##  Tolerations for pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []
        
  persistence:
    enabled: true
    accessModes:
    - ReadWriteOnce
    size: 20Gi


metricsExporter:
  image:
    registry: docker.io
    repository: digmatic/k8s-metrics-exporter
    tag: 0.0.10-alpha.2
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: 1
  resources: 
    requests: 
      memory: 512Mi
      cpu: 500m
    limits: 
      memory: 768Mi
      cpu: 750m
  service:
    ports:
      http: 9090
    ## Annotations for service
    ##
    annotations: {}
  serviceAccount:
    annotations: {}

  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []




otelCollectorDf:
  fullnameOverride: "digma-otel-collector-df" # because we need to use this name other value in file
  image:
    registry: docker.io
    repository: otel/opentelemetry-collector-contrib
    tag: 0.103.0
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    limits:
      cpu: 200m
      memory: 300Mi
  service:
    ## @param Annotations for service
    ##
    annotations: {}
    ports:
      grpc: 4317
      prometheus_scraper: 8889
  ## Extra labels for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ##  Annotations for pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ##  Node labels for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ##  Tolerations for pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  
digmaSelfDiagnosis:
  otlpExportTraces: false
  otlpExportMetrics: false
  otlpExportLogs: false
  otlpExporterEndpoint: local # either a url or 'local'
  otlpSamplerProbability: "0.1"



digma:
  environmentName: digma
  environmentType: Public
  siteName: undefined
  isCentralize: true
  licenseKey: "7df80c6f820a4ec5a81fe6325769c88b"